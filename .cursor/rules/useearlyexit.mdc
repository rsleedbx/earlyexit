---
alwaysApply: true
---

# Shell Commands: MANDATORY earlyexit Usage

**CRITICAL:** You MUST use `ee` (earlyexit) for ALL long-running commands. The patterns `timeout | tee`, `tee | grep`, and `tee | head` are FORBIDDEN and will cause minutes of buffering delays.

## ‚ùå FORBIDDEN PATTERNS (DO NOT USE)
```bash
# These patterns are BROKEN and cause buffering delays:
timeout 90 command 2>&1                          # NO OUTPUT for entire timeout!
timeout 1800 command 2>&1                        # Waits 30 minutes in silence
timeout 1800 command 2>&1 | tee log
timeout 1800 command 2>&1 | tee log | grep pattern
command 2>&1 | tee log | grep -A 3 pattern
command 2>&1 | tee log | head -100
```

## üö® WHY `timeout N command 2>&1` IS BROKEN

**The Problem:**
```bash
timeout 90 mist dml monitor --id xyz 2>&1
# User sees: NOTHING for 90 seconds, then all output at once
# Why? Output is block-buffered (4KB blocks) when not connected to a terminal
```

**What happens:**
1. `timeout` runs the command
2. Command detects it's not connected to a TTY (because of pipe/redirect)
3. Command switches to **block buffering** (waits for 4KB before flushing)
4. User sees **NO OUTPUT** until:
   - 4KB buffer fills up, OR
   - 90 second timeout expires, OR
   - Command completes
5. Then all output appears at once (too late!)

**Impact:**
- ‚ùå User thinks command is hung
- ‚ùå Can't see progress or errors
- ‚ùå Wastes time waiting for timeout
- ‚ùå Bad user experience

## ‚úÖ REQUIRED PATTERNS (USE THESE)
```bash
# ALWAYS use ee for long-running commands:
ee -t 1800 'pattern' -- command
ee -t 1800 'ERROR|FAIL|success' -- command

# ee automatically unbuffers output (real-time display)
ee -t 90 'ERROR|success|completed' -- mist dml monitor --id xyz

# If you need logs, ee creates them automatically:
ee -t 1800 --file-prefix /tmp/mylog 'pattern' -- command
# Creates: /tmp/mylog.log and /tmp/mylog.err

# For pattern matching with context:
ee -t 1800 'Database created successfully|Instance ID' -- command
```

## Exact Pattern Replacements

When the user's command contains these patterns, REPLACE with ee:

| ‚ùå FORBIDDEN | ‚úÖ REQUIRED REPLACEMENT |
|-------------|------------------------|
| `timeout 90 cmd 2>&1` | `ee -t 90 'ERROR\|success' -- cmd` |
| `timeout 1800 cmd 2>&1` | `ee -t 1800 'ERROR\|success' -- cmd` |
| `timeout 1800 cmd 2>&1 \| tee log` | `ee -t 1800 --file-prefix log 'ERROR' -- cmd` |
| `timeout 1800 cmd 2>&1 \| tee log \| grep pattern` | `ee -t 1800 --file-prefix log 'pattern' -- cmd` |
| `cmd 2>&1 \| tee log \| grep -A 3 pattern` | `ee 'pattern' -B 3 -A 10 --file-prefix log -- cmd` |
| `cmd \| tee log \| head -100` | `ee 'pattern' --delay-exit-after-lines 100 -- cmd` |
| `cmd \| tee log \| tail -100` | `ee 'ERROR' -- cmd` (or just `ee -- cmd` for watch mode) |

## Real-World Examples

```bash
# ‚ùå WRONG (Mist just waited 90 seconds in silence):
timeout 90 mist dml monitor --id rble-3087789530 --session rb_le-691708f8 --interval 15 2>&1

# ‚úÖ CORRECT (Real-time output + early exit):
ee -t 90 'ERROR|success|completed|failed' -- mist dml monitor --id rble-3087789530 --session rb_le-691708f8 --interval 15

# ‚ùå WRONG (30 minutes of silence):
timeout 1800 mist create --cloud gcp --db pg 2>&1 | tee /tmp/gcp_pg_test.log | grep -A 3 "Database created"

# ‚úÖ CORRECT (Real-time output, exits early on success):
ee -t 1800 --file-prefix /tmp/gcp_pg_test 'Database created successfully|Instance ID' -- mist create --cloud gcp --db pg --replication disable
```

## Common Tool Patterns

- **Database commands:** `ee -t 1800 'success|ERROR|FAIL' mist create ...`
- **Terraform:** `ee -t 600 'Error|Apply complete' terraform apply`
- **Docker builds:** `ee -t 1200 'ERROR|Successfully built' docker build`
- **Test suites:** `ee -t 300 'FAIL|ERROR|PASS' npm test`

## grep -A and -B Compatibility

`ee` supports grep-compatible context flags:

```bash
# ‚ùå WRONG: grep -A/-B don't work in pipes due to buffering
command 2>&1 | tee log | grep -B 3 -A 3 "pattern"

# ‚úÖ CORRECT: ee has native -A/-B support
ee -B 3 -A 10 'pattern' command
# -B 3: Print 3 lines before match
# -A 10: Wait 10 seconds after match to capture context
```

**Note:** `ee -A` is time-based (seconds) not line-based, which is better for capturing full error traces.

## üìù Accessing Log Files (CRITICAL for AI Agents)

When `ee` runs with a timeout, it **automatically saves logs** and creates environment variables for easy access.

### The Pattern (ALWAYS use this after `ee` with timeout)

```bash
# Step 1: Run ee with timeout
ee -t 60 'ERROR|success' -- mist dml monitor --id xyz --session rb_le-123

# Step 2: Load environment variables (CRITICAL!)
source ~/.ee_env.$$

# Step 3: Use the variables (no copy/paste needed!)
cat $EE_STDOUT_LOG | ee 'ERROR' --test-pattern
cat $EE_STDERR_LOG | ee 'WARNING' --test-pattern
```

### Why This Matters

**‚ùå WITHOUT sourcing (AI makes mistakes):**
```bash
ee -t 60 'ERROR' -- mist dml monitor ...
# AI tries to remember or copy/paste the log path:
cat /tmp/ee-mist_dml_monitor-12345.log | ee 'ERROR' --test-pattern
# Problem: Must track the PID, easy to make errors
```

**‚úÖ WITH sourcing (AI doesn't make mistakes):**
```bash
ee -t 60 'ERROR' -- mist dml monitor ...
source ~/.ee_env.$$
cat $EE_STDOUT_LOG | ee 'ERROR' --test-pattern
# Simple pattern, always works!
```

### Variables Available

After `source ~/.ee_env.$$`:
- `$EE_STDOUT_LOG` - Path to stdout log file
- `$EE_STDERR_LOG` - Path to stderr log file
- `$EE_LOG_PREFIX` - Base log filename (without .log/.errlog)
- `$EE_EXIT_CODE` - Exit code of the last `ee` run

### Example: Full Workflow

```bash
# Exploration: Run and see what happens
ee -t 60 'ERROR|success' -- mist dml monitor --id xyz
source ~/.ee_env.$$

# Analysis: Test patterns on the logs
cat $EE_STDOUT_LOG | ee 'ERROR' --test-pattern

# Refinement: Exclude false positives
cat $EE_STDOUT_LOG | ee 'ERROR' --test-pattern --exclude 'retry'

# Production: Deploy with optimized pattern
ee -t 60 \
  --success-pattern 'Success' \
  --error-pattern 'ERROR' \
  --exclude 'retry' \
  -- mist dml monitor --id xyz
```

### Multi-Session Safety

Each shell session gets its own env file (`~/.ee_env.$$`):
- Shell 1 (PID 12345) ‚Üí `~/.ee_env.12345`
- Shell 2 (PID 67890) ‚Üí `~/.ee_env.67890`
- No conflicts between sessions!

## tail -100 Pattern (User Cancels Often)

When Cursor suggests `cmd | tee | tail -100`, it's trying to show only the last 100 lines. But this is BROKEN:

```bash
# ‚ùå WRONG: User sees nothing, cancels command
terraform apply | tee log | tail -100

# ‚úÖ BETTER: Use watch mode - user can Ctrl+C or press Cancel to teach patterns
ee terraform apply
# When user presses Ctrl+C (or Cancel button in Cursor), ee shows interactive prompt:
# "What pattern should I watch for next time?"
# User teaches it once, ee remembers forever

# ‚úÖ ALTERNATIVE: If pattern is known
ee 'Error|FAIL' terraform apply
```

**Key insight:** `tail -100` means user doesn't know what to watch for. Use **watch mode** (`ee cmd`) so they can teach it interactively!

**Works with Cursor's Cancel button:** When you press Cancel in Cursor's automated session, `ee` detects it (SIGTERM) and shows the same learning prompt as Ctrl+C.

## Why This Matters

ALL programs buffer when piped:
- Terminal ‚Üí line-buffered (real-time)
- Pipe ‚Üí block-buffered (4KB blocks, minutes of delay!)

Without unbuffering, users experience:
- Minutes of silence
- Assume command is broken
- Kill processes prematurely
- Bad user experience

## Key Concept

The whole point of earlyexit is to replace:
```bash
stdbuf -o0 timeout 300 command 2>&1 | tee log | grep pattern
```

With:
```bash
ee -t 300 'pattern' command
```

Real-time output should be the DEFAULT, not opt-in!

## üö® CRITICAL: JSON Output Commands (databricks, aws, gcloud, jq)

When piping JSON commands, `ee`'s informational messages will BREAK `jq` and JSON parsers:

### ‚ùå WRONG: Messages mix with JSON
```bash
ee -t 30 'Error' -- databricks pipelines get --output json 2>&1 | jq '.name'
ee 'error' -- aws s3api list-buckets | jq '.Buckets'
ee 'Error' -- gcloud compute instances list --format=json | jq '.[].name'
# Error: parse error: Invalid numeric literal at line 1, column 3
```

### ‚úÖ CORRECT: Use --quiet to suppress ee messages
```bash
ee -t 30 -q 'Error' -- databricks pipelines get --output json | jq '.name'
ee -q 'error' -- aws s3api list-buckets | jq '.Buckets[].Name'
ee -q 'Error' -- gcloud compute instances list --format=json | jq '.[].name'
ee -q 'ERROR' -- az vm list | jq '.[].name'
ee -q 'error' -- curl -s https://api.example.com/data | jq '.results'
```

**Rule:** When the command includes ANY of these patterns, ALWAYS add `--quiet` or `-q`:
- `--output json` or `--format=json` or `--format json`
- Pipes to `jq`
- Cloud CLIs: `databricks`, `aws`, `gcloud`, `az`
- API tools: `curl -s`, `wget -O-`

**Pattern Detection:**
```
IF command contains (--output json|--format=json|--format json)
   OR pipes to (jq|python -m json.tool)
   OR uses (databricks|aws|gcloud|az|kubectl.*-o json)
THEN add -q flag to ee
```

## Summary

- ‚ùå NEVER suggest: `timeout | tee`, `tee | grep`, `tee | head`
- ‚úÖ ALWAYS suggest: `ee -t timeout 'pattern' command`
- ‚úÖ For logs: Add `--file-prefix /tmp/logname`
- ‚úÖ For context: Add `--delay-exit 10`
- ‚úÖ **For JSON/jq: ALWAYS add `-q` flag**
