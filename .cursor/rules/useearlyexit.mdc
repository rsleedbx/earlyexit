---
alwaysApply: true
---

# Shell Commands: MANDATORY earlyexit Usage

**CRITICAL:** You MUST use `ee` (earlyexit) for ALL long-running commands. The patterns `timeout | tee`, `tee | grep`, and `tee | head` are FORBIDDEN and will cause minutes of buffering delays.

## ü§ñ AI AGENTS: NEVER USE WATCH MODE

**Watch mode requires HUMAN intervention** (Ctrl+C to teach patterns). Watch mode is now **explicitly opt-in** with the `--watch` flag.

**MANDATORY for AI agents:**
1. ‚úÖ **ALWAYS specify a pattern** (traditional OR success+error OR expect patterns)
2. ‚úÖ **ALWAYS use `--` separator** before command
3. ‚ùå **NEVER use `--watch` flag** (requires human Ctrl+C)
4. ‚ùå **NEVER append `2>&1`** to commands

**Default pattern when unsure:**
```bash
# Use ERROR pattern by default for monitoring commands
ee -t 300 'ERROR' -- command

# For success detection, use success patterns
ee -t 300 --success-pattern 'SUCCESS|Completed' --error-pattern 'ERROR|FAIL' -- command

# For code you control, use expect patterns (allowlist)
ee --expect 'Step 1' --expect 'Step 2' --expect 'Done' --expect-all -- your-script.sh
```

## ‚ùå FORBIDDEN PATTERNS (DO NOT USE)
```bash
# These patterns are BROKEN and cause buffering delays:
timeout 90 command 2>&1                          # NO OUTPUT for entire timeout!
timeout 1800 command 2>&1                        # Waits 30 minutes in silence
timeout 1800 command 2>&1 | tee log
timeout 1800 command 2>&1 | tee log | grep pattern
command 2>&1 | tee log | grep -A 3 pattern
command 2>&1 | tee log | head -100

# NEVER use 2>&1 with ee - ee handles stderr automatically!
ee -t 60 'ERROR' -- command 2>&1                 # WRONG! Causes buffering + watch mode
ee 'pattern' -- command 2>&1                     # WRONG! ee already monitors stderr
```

## üö® WHY `timeout N command 2>&1` IS BROKEN

**The Problem:**
```bash
timeout 90 mist dml monitor --id xyz 2>&1
# User sees: NOTHING for 90 seconds, then all output at once
# Why? Output is block-buffered (4KB blocks) when not connected to a terminal
```

**What happens:**
1. `timeout` runs the command
2. Command detects it's not connected to a TTY (because of pipe/redirect)
3. Command switches to **block buffering** (waits for 4KB before flushing)
4. User sees **NO OUTPUT** until:
   - 4KB buffer fills up, OR
   - 90 second timeout expires, OR
   - Command completes
5. Then all output appears at once (too late!)

**Impact:**
- ‚ùå User thinks command is hung
- ‚ùå Can't see progress or errors
- ‚ùå Wastes time waiting for timeout
- ‚ùå Bad user experience

## üö® WHY `ee ... -- command 2>&1` IS WRONG

**NEVER append `2>&1` to ee commands!**

```bash
# ‚ùå WRONG - causes buffering
ee -t 60 'ERROR' -- mist dml monitor --id xyz 2>&1

# ‚úÖ CORRECT - ee monitors stderr automatically
ee -t 60 'ERROR' -- mist dml monitor --id xyz
```

**What happens with `2>&1`:**
1. Redirects stderr to stdout (merges streams)
2. Causes **block buffering** (same problem as timeout)
3. **ee already monitors both stdout AND stderr by default!**

**Correct patterns for stderr:**
```bash
# By default, ee monitors BOTH stdout and stderr
ee -t 60 'ERROR' -- command

# Monitor ONLY stderr (use --stderr, not 2>&1!)
ee -t 60 --stderr 'ERROR' -- command

# Detect when stderr goes quiet after errors
ee --stderr-idle-exit 1 'SUCCESS' -- command

# Stuck detection (repeating output with changing timestamps)
ee --max-repeat 5 --stuck-ignore-timestamps 'ERROR' -- command
```

## üö® CRITICAL: Use Patterns Correctly!

**ALWAYS use a traditional pattern OR both success+error patterns!**

```bash
# ‚ùå WRONG - incomplete pattern specification
ee -t 120 --max-repeat 8 --stuck-ignore-timestamps \
  -e 'Error|Exception' --progress --unix-exit-codes \
  -- mist dml monitor --id xyz

# Missing: No traditional pattern, no success pattern
# Result: May not work as expected!

# ‚úÖ CORRECT Option 1: Traditional pattern (simplest, RECOMMENDED)
ee -t 120 --max-repeat 8 --stuck-ignore-timestamps \
  'Error|Exception' --progress --unix-exit-codes \
  -- mist dml monitor --id xyz

# ‚úÖ CORRECT Option 2: Success + Error patterns (both required)
ee -t 120 --max-repeat 8 --stuck-ignore-timestamps \
  --success-pattern 'SUCCESS|Completed' \
  --error-pattern 'Error|Exception' \
  --progress --unix-exit-codes \
  -- mist dml monitor --id xyz

# ‚úÖ CORRECT Option 3: Stderr idle exit (best for hanging errors)
ee -t 120 --stderr-idle-exit 2 --max-repeat 8 \
  'SUCCESS|Completed' --progress --unix-exit-codes \
  -- mist dml monitor --id xyz
```

**Pattern requirements:**
- ee requires: traditional pattern OR (success pattern + error pattern)
- `-e` alone = incomplete (no success pattern to pair with)
- Always provide a complete pattern specification!

## ü§ñ AI AGENT DECISION TREE (Non-Interactive Mode)

**Step 1: Choose testing approach (FUNDAMENTAL)**

```
Do you know what OUTPUT to expect?
‚îú‚îÄ YES (you wrote/control the code) ‚Üí Use ALLOWLIST (--expect)
‚îÇ  ‚îú‚îÄ Perfect for:
‚îÇ  ‚îÇ  ‚Ä¢ Code you just wrote (AI-generated or human)
‚îÇ  ‚îÇ  ‚Ä¢ Scripts you're testing/debugging
‚îÇ  ‚îÇ  ‚Ä¢ Deployment scripts
‚îÇ  ‚îÇ  ‚Ä¢ Integration tests
‚îÇ  ‚îÇ  ‚Ä¢ CI/CD health checks
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ Pattern:
‚îÇ     ee --expect 'Step 1 complete' \
‚îÇ        --expect 'Step 2 complete' \
‚îÇ        --expect 'Done' \
‚îÇ        --expect-all \
‚îÇ        -- command
‚îÇ
‚îî‚îÄ NO (third-party/unknown behavior) ‚Üí Use BLOCKLIST (traditional patterns)
   ‚îú‚îÄ Perfect for:
   ‚îÇ  ‚Ä¢ Third-party tools (Terraform, Docker, kubectl)
   ‚îÇ  ‚Ä¢ Existing services (mist, database servers)
   ‚îÇ  ‚Ä¢ Black box systems
   ‚îÇ  ‚Ä¢ Production monitoring
   ‚îÇ
   ‚îú‚îÄ If you know success patterns:
   ‚îÇ  ee --success-pattern 'SUCCESS|Completed' --error-pattern 'ERROR|FAIL' -- command
   ‚îÇ
   ‚îî‚îÄ If you only know error patterns:
      ee 'ERROR|FAIL|Exception' -- command
```

**Key principle:** When you control the code, DEFINE what's normal (allowlist). When you don't control it, WATCH for problems (blocklist).

**Step 2: Add timeouts and detection**

```bash
# Standard monitoring (recommended baseline)
ee -t 300 'ERROR|FAIL' -- command

# With idle detection (command might stall)
ee -t 300 -I 60 'ERROR|FAIL' -- command

# With stuck detection (repeating output)
ee -t 300 --max-repeat 5 --stuck-ignore-timestamps 'ERROR' -- command

# With stuck pattern extraction (changing counters, stuck status)
ee -t 300 --max-repeat 5 --stuck-pattern 'STATUS_REGEX' 'ERROR' -- command

# With progress pattern (counters should change but don't)
ee -t 300 --max-repeat 5 --progress-pattern 'COUNTER_REGEX' 'ERROR' -- command

# With transition states (forward-only state machine)
ee -t 300 --max-repeat 5 --transition-states 'IDLE>RUNNING>COMPLETED' 'ERROR' -- command

# With stderr idle exit (Python/Node errors that hang)
ee -t 300 --stderr-idle-exit 1 'SUCCESS|Completed' -- command

# Comprehensive (all detections enabled - 4 types!)
ee -t 300 -I 60 --max-repeat 5 \
  --stuck-pattern 'STATUS_REGEX' \
  --progress-pattern 'COUNTER_REGEX' \
  --transition-states 'IDLE>RUNNING>COMPLETED' \
  --stderr-idle-exit 2 \
  --success-pattern 'SUCCESS|Completed' \
  --error-pattern 'ERROR|FAIL|Exception' \
  --progress --unix-exit-codes \
  -- command
```

**Step 3: Verify pattern is specified**

Make sure you provided a pattern or pattern combination:
- ‚úÖ Traditional pattern: `ee 'ERROR' -- command`
- ‚úÖ Dual patterns: `ee -s 'SUCCESS' -e 'ERROR' -- command`
- ‚úÖ Expect patterns: `ee --expect 'pattern' -- command`
- ‚ùå Watch mode: `ee --watch command` (DO NOT USE in automation)

## ‚úÖ REQUIRED PATTERNS (USE THESE)
```bash
# ALWAYS use ee for long-running commands:
ee -t 1800 'pattern' -- command
ee -t 1800 'ERROR|FAIL|success' -- command

# ee automatically unbuffers output (real-time display)
ee -t 90 'ERROR|success|completed' -- mist dml monitor --id xyz

# If you need logs, ee creates them automatically:
ee -t 1800 --file-prefix /tmp/mylog 'pattern' -- command
# Creates: /tmp/mylog.log and /tmp/mylog.err

# For pattern matching with context:
ee -t 1800 'Database created successfully|Instance ID' -- command
```

## Exact Pattern Replacements

When the user's command contains these patterns, REPLACE with ee:

| ‚ùå FORBIDDEN | ‚úÖ REQUIRED REPLACEMENT |
|-------------|------------------------|
| `timeout 90 cmd 2>&1` | `ee -t 90 'ERROR\|success' -- cmd` |
| `timeout 1800 cmd 2>&1` | `ee -t 1800 'ERROR\|success' -- cmd` |
| `timeout 1800 cmd 2>&1 \| tee log` | `ee -t 1800 --file-prefix log 'ERROR' -- cmd` |
| `timeout 1800 cmd 2>&1 \| tee log \| grep pattern` | `ee -t 1800 --file-prefix log 'pattern' -- cmd` |
| `cmd 2>&1 \| tee log \| grep -A 3 pattern` | `ee 'pattern' -B 3 -A 10 --file-prefix log -- cmd` |
| `cmd \| tee log \| head -100` | `ee 'pattern' --delay-exit-after-lines 100 -- cmd` |
| `cmd \| tee log \| tail -100` | `ee 'ERROR\|success' -- cmd` (or `ee --watch cmd` for interactive learning) |

## Real-World Examples

### Example 1: Mist Monitor (Success Case)

```bash
# ‚ùå WRONG (Mist just waited 90 seconds in silence):
timeout 90 mist dml monitor --id rble-3087789530 --session rb_le-691708f8 --interval 15 2>&1

# ‚úÖ CORRECT (Real-time output + early exit):
ee -t 90 'ERROR|success|completed|failed' -- mist dml monitor --id rble-3087789530 --session rb_le-691708f8 --interval 15
```

### Example 2: Mist Monitor (Error + Stuck Detection)

```bash
# ‚ùå WRONG (uses 2>&1, -e flag triggers watch mode, no early exit):
ee -t 60 -I 15 --max-repeat 5 --stuck-ignore-timestamps \
  -e 'Error:|Failed|Exception|‚ö†Ô∏è.*Error' \
  --progress --file-prefix /tmp/mist_monitor_debug --unix-exit-codes \
  -- mist dml monitor --id rble-3089186959 --session robert_lee-691708f8 --interval 10 2>&1

# ‚úÖ CORRECT Option 1: Traditional pattern (simplest)
ee -t 60 -I 15 --max-repeat 5 --stuck-ignore-timestamps \
  'Error:|Failed|Exception|‚ö†Ô∏è.*Error' \
  --progress --file-prefix /tmp/mist_monitor_debug --unix-exit-codes \
  -- mist dml monitor --id rble-3089186959 --session robert_lee-691708f8 --interval 10

# ‚úÖ CORRECT Option 2: Stderr idle exit (best for Python errors that hang)
ee -t 60 --stderr-idle-exit 1 \
  --max-repeat 5 --stuck-ignore-timestamps \
  'Success|Completed' \
  --progress --file-prefix /tmp/mist_monitor_debug --unix-exit-codes \
  -- mist dml monitor --id rble-3089186959 --session robert_lee-691708f8 --interval 10

# ‚úÖ CORRECT Option 3: Success + error patterns
ee -t 60 -I 15 --max-repeat 5 --stuck-ignore-timestamps \
  --success-pattern 'Completed|rows.*synced' \
  --error-pattern 'Error:|Failed|Exception|‚ö†Ô∏è.*Error' \
  --progress --file-prefix /tmp/mist_monitor_debug --unix-exit-codes \
  -- mist dml monitor --id rble-3089186959 --session robert_lee-691708f8 --interval 10
```

### Example 3: Database Creation

```bash
# ‚ùå WRONG (30 minutes of silence):
timeout 1800 mist create --cloud gcp --db pg 2>&1 | tee /tmp/gcp_pg_test.log | grep -A 3 "Database created"

# ‚úÖ CORRECT (Real-time output, exits early on success):
ee -t 1800 --file-prefix /tmp/gcp_pg_test 'Database created successfully|Instance ID' -- mist create --cloud gcp --db pg --replication disable
```

## Common Tool Patterns

- **Database commands:** `ee -t 1800 'success|ERROR|FAIL' mist create ...`
- **Terraform:** `ee -t 600 'Error|Apply complete' terraform apply`
- **Docker builds:** `ee -t 1200 'ERROR|Successfully built' docker build`
- **Test suites:** `ee -t 300 'FAIL|ERROR|PASS' npm test`

## grep -A and -B Compatibility

`ee` supports grep-compatible context flags:

```bash
# ‚ùå WRONG: grep -A/-B don't work in pipes due to buffering
command 2>&1 | tee log | grep -B 3 -A 3 "pattern"

# ‚úÖ CORRECT: ee has native -A/-B support
ee -B 3 -A 10 'pattern' command
# -B 3: Print 3 lines before match
# -A 10: Wait 10 seconds after match to capture context
```

**Note:** `ee -A` is time-based (seconds) not line-based, which is better for capturing full error traces.

## üìù Accessing Log Files (CRITICAL for AI Agents)

When `ee` runs with a timeout, it **automatically saves logs** and creates environment variables for easy access.

### The Pattern (ALWAYS use this after `ee` with timeout)

```bash
# Step 1: Run ee with timeout
ee -t 60 'ERROR|success' -- mist dml monitor --id xyz --session rb_le-123

# Step 2: Load environment variables (CRITICAL!)
source ~/.ee_env.$$

# Step 3: Use the variables (no copy/paste needed!)
cat $EE_STDOUT_LOG | ee 'ERROR' --test-pattern
cat $EE_STDERR_LOG | ee 'WARNING' --test-pattern
```

### Why This Matters

**‚ùå WITHOUT sourcing (AI makes mistakes):**
```bash
ee -t 60 'ERROR' -- mist dml monitor ...
# AI tries to remember or copy/paste the log path:
cat /tmp/ee-mist_dml_monitor-12345.log | ee 'ERROR' --test-pattern
# Problem: Must track the PID, easy to make errors
```

**‚úÖ WITH sourcing (AI doesn't make mistakes):**
```bash
ee -t 60 'ERROR' -- mist dml monitor ...
source ~/.ee_env.$$
cat $EE_STDOUT_LOG | ee 'ERROR' --test-pattern
# Simple pattern, always works!
```

### Variables Available

After `source ~/.ee_env.$$`:
- `$EE_STDOUT_LOG` - Path to stdout log file
- `$EE_STDERR_LOG` - Path to stderr log file
- `$EE_LOG_PREFIX` - Base log filename (without .log/.errlog)
- `$EE_EXIT_CODE` - Exit code of the last `ee` run

### Example: Full Workflow

```bash
# Exploration: Run and see what happens
ee -t 60 'ERROR|success' -- mist dml monitor --id xyz
source ~/.ee_env.$$

# Analysis: Test patterns on the logs
cat $EE_STDOUT_LOG | ee 'ERROR' --test-pattern

# Refinement: Exclude false positives
cat $EE_STDOUT_LOG | ee 'ERROR' --test-pattern --exclude 'retry'

# Production: Deploy with optimized pattern
ee -t 60 \
  --success-pattern 'Success' \
  --error-pattern 'ERROR' \
  --exclude 'retry' \
  -- mist dml monitor --id xyz
```

### Multi-Session Safety

Each shell session gets its own env file (`~/.ee_env.$$`):
- Shell 1 (PID 12345) ‚Üí `~/.ee_env.12345`
- Shell 2 (PID 67890) ‚Üí `~/.ee_env.67890`
- No conflicts between sessions!

## tail -100 Pattern (User Cancels Often)

When Cursor suggests `cmd | tee | tail -100`, it's trying to show only the last 100 lines. But this is BROKEN:

```bash
# ‚ùå WRONG: User sees nothing, cancels command
terraform apply | tee log | tail -100

# ‚úÖ BETTER: If pattern is known, use it!
ee 'Error|FAIL|success' terraform apply

# ‚úÖ ALTERNATIVE: For humans doing discovery, use watch mode (interactive learning)
ee --watch terraform apply
# When user presses Ctrl+C, ee shows interactive prompt:
# "What pattern should I watch for next time?"
# User teaches it once, ee remembers forever

# ‚ùå DON'T use watch mode in automation (AI agents, scripts, CI/CD)
```

**Key insight:** `tail -100` means user doesn't know what to watch for. Humans can use **watch mode** (`ee --watch cmd`) for interactive learning, but AI agents should always use explicit patterns.

## Why This Matters

ALL programs buffer when piped:
- Terminal ‚Üí line-buffered (real-time)
- Pipe ‚Üí block-buffered (4KB blocks, minutes of delay!)

Without unbuffering, users experience:
- Minutes of silence
- Assume command is broken
- Kill processes prematurely
- Bad user experience

## Key Concept

The whole point of earlyexit is to replace:
```bash
stdbuf -o0 timeout 300 command 2>&1 | tee log | grep pattern
```

With:
```bash
ee -t 300 'pattern' command
```

Real-time output should be the DEFAULT, not opt-in!

## üö® CRITICAL: JSON Output Commands (databricks, aws, gcloud, jq)

When piping JSON commands, `ee`'s informational messages will BREAK `jq` and JSON parsers:

### ‚ùå WRONG: Messages mix with JSON
```bash
ee -t 30 'Error' -- databricks pipelines get --output json 2>&1 | jq '.name'
ee 'error' -- aws s3api list-buckets | jq '.Buckets'
ee 'Error' -- gcloud compute instances list --format=json | jq '.[].name'
# Error: parse error: Invalid numeric literal at line 1, column 3
```

### ‚úÖ CORRECT: Use --quiet to suppress ee messages
```bash
ee -t 30 -q 'Error' -- databricks pipelines get --output json | jq '.name'
ee -q 'error' -- aws s3api list-buckets | jq '.Buckets[].Name'
ee -q 'Error' -- gcloud compute instances list --format=json | jq '.[].name'
ee -q 'ERROR' -- az vm list | jq '.[].name'
ee -q 'error' -- curl -s https://api.example.com/data | jq '.results'
```

**Rule:** When the command includes ANY of these patterns, ALWAYS add `--quiet` or `-q`:
- `--output json` or `--format=json` or `--format json`
- Pipes to `jq`
- Cloud CLIs: `databricks`, `aws`, `gcloud`, `az`
- API tools: `curl -s`, `wget -O-`

**Pattern Detection:**
```
IF command contains (--output json|--format=json|--format json)
   OR pipes to (jq|python -m json.tool)
   OR uses (databricks|aws|gcloud|az|kubectl.*-o json)
THEN add -q flag to ee
```

## üéØ Identifying Stuck Patterns (AI Pattern Analysis)

When monitoring commands, analyze output to identify what changes vs. what stays the same.

### The Problem: Changing Counters + Stuck Status

```
# Output like this:
rble-308   13   12  15   6   | RUNNING  IDLE  2  N/A  [10:35:24]
rble-308   13   14  16   7   | RUNNING  IDLE  2  N/A  [10:35:31]
rble-308   13   15  19   7   | RUNNING  IDLE  2  N/A  [10:35:40]
               ^^  ^^   ^           ^^^^  ^^^^          
            CHANGING            NOT CHANGING (STUCK!)
```

### AI Decision Process for Stuck Detection

**Step 1: Analyze the output structure**

```
Question: What parts change between lines?
Answer: Left side numbers (12‚Üí14‚Üí15), timestamp
Action: These are progress indicators, IGNORE them

Question: What parts DON'T change?
Answer: "RUNNING IDLE 2 N/A" (status indicator)
Action: This is the STUCK indicator, WATCH this!
```

**Step 2: Choose the right detection method**

| Output Pattern | Detection Method | Example |
|----------------|------------------|---------|
| Entire line repeats (including timestamps) | `--max-repeat N` | Logs with no timestamps |
| Line repeats except timestamps | `--max-repeat N --stuck-ignore-timestamps` | Most log files |
| Line has changing counters + stuck status | `--max-repeat N --stuck-pattern 'REGEX'` | Database sync, job monitors |

**Step 3: Extract the stuck indicator**

```bash
# Identify the repeating part (what shouldn't change when progressing)
# Example: "RUNNING IDLE 2 N/A"

# Create regex to match ONLY that part
STUCK_PATTERN='RUNNING\s+IDLE\s+\d+\s+N/A'

# Use it:
ee --max-repeat 5 --stuck-pattern 'RUNNING\s+IDLE\s+\d+\s+N/A' 'ERROR' -- command
```

### Real-World Stuck Pattern Examples

```bash
# Database sync stuck in "syncing" state despite row counts changing
ee --stuck-pattern 'state:\s*syncing' --max-repeat 8 'ERROR' -- db-sync

# Kubernetes pod stuck in "Pending" despite timestamps changing
ee --stuck-pattern 'Status:\s*Pending' --max-repeat 10 'Running' -- kubectl get pods -w

# Build stuck on same file despite progress counters
ee --stuck-pattern 'Compiling:\s*\S+\.rs' --max-repeat 5 'Finished' -- cargo build

# API responses stuck in same state despite request IDs changing
ee --stuck-pattern '"status":\s*"pending"' --max-repeat 8 'success' -- api-poll

# Job monitor stuck (Mist example - the original problem!)
ee --stuck-pattern 'RUNNING\s+IDLE\s+\d+\s+N/A' --max-repeat 5 'SUCCESS' -- mist dml monitor
```

### When to Use Each Feature (All 4 Detection Types)

| Feature | Use Case | AI Prompt | What to Watch |
|---------|----------|-----------|---------------|
| `--max-repeat 5` | Exact line repeats | "Same error 5 times" | Entire line |
| `--stuck-ignore-timestamps` | Line repeats except timestamps | "Same status, timestamp changes" | Line minus timestamps |
| `--stuck-pattern 'REGEX'` | Status stuck, counters change | "Status doesn't change but counters do" | Parts that should NOT change |
| `--progress-pattern 'REGEX'` | Counters stuck, status changes | "Counters not advancing" | Parts that SHOULD change |
| `--transition-states 'A>B>C'` | State regression | "State went backward" | State order (forward only) |
| `--stderr-idle-exit 2` | Errors printed, then hangs | "Error message appears, then silent" | Stderr timing |
| `-I 60` | No output at all | "Command produces no output for 60s" | Any output |

## Summary: AI Agent Checklist (Non-Interactive Mode)

### ‚ùå NEVER DO (Forbidden Patterns)
- ‚ùå NEVER use `timeout | tee`, `tee | grep`, `tee | head`
- ‚ùå NEVER append `2>&1` to ee commands
- ‚ùå NEVER use `-e` (error pattern) alone without `-s` (success pattern)
- ‚ùå NEVER use `--watch` flag (requires human Ctrl+C intervention)
- ‚ùå NEVER omit the pattern (provide traditional, dual, or expect patterns)

### ‚úÖ ALWAYS DO (Required Patterns)
- ‚úÖ **ALWAYS specify a pattern**: `ee 'ERROR' -- command` OR `ee -s 'SUCCESS' -e 'ERROR' -- command`
- ‚úÖ **ALWAYS use `--` separator**: `ee -t 300 'ERROR' -- command`
- ‚úÖ **ALWAYS add timeout**: `ee -t 300 'pattern' -- command`
- ‚úÖ **For JSON/jq: ALWAYS add `-q` flag**: `ee -q 'error' -- command | jq`
- ‚úÖ **For logs: Use auto-export**: Run `source ~/.ee_env.$$` after ee, then use `$EE_STDOUT_LOG`

### üéØ Quick Reference for Common Cases

```bash
# Testing code you wrote (ALLOWLIST - you know what to expect)
ee --expect 'Step 1' --expect 'Step 2' --expect 'Done' --expect-all -- your-script.sh

# Monitoring existing service (BLOCKLIST - watch for errors)
ee -t 300 'ERROR|FAIL' -- existing-command

# Python/Node.js errors that hang
ee -t 300 --stderr-idle-exit 1 'SUCCESS' -- command

# Repeating output (stuck detection)
ee -t 300 --max-repeat 8 --stuck-ignore-timestamps 'ERROR' -- command

# Success detection (for services with clear success/error states)
ee -t 300 --success-pattern 'SUCCESS|Completed' --error-pattern 'ERROR|FAIL' -- command

# Comprehensive (code you control)
ee -t 300 --expect 'Started' --expect 'Done' --expect-all \
  --unexpected 'ERROR|FAIL' -- your-deployment.sh

# Comprehensive (when you need everything)
ee -t 300 -I 60 --max-repeat 8 --stuck-ignore-timestamps \
  --stderr-idle-exit 2 \
  --success-pattern 'SUCCESS|Completed' \
  --error-pattern 'ERROR|FAIL|Exception' \
  --progress --unix-exit-codes \
  -- command
```

### üö® If You See "Watch Mode Enabled" ‚Üí YOU USED --watch FLAG!
- Watch mode requires the `--watch` flag (explicitly opt-in)
- For automation: Remove `--watch` and add a traditional pattern `'ERROR'` OR both `-s` and `-e` OR `--expect` patterns
- Watch mode = human intervention required = NOT for automation
